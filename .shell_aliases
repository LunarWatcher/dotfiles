# Globals {{{
local loc=$(readlink ~/.zshrc)
export DOTFILES_HOME=$(dirname $loc)
# }}}
# Builtins {{{
# ls without colors for dipshit 777 disks
# The colorscheme makes 777 folders literally unreadable
alias lsn="ls --color=no"

# Folder Open, opens the current folder
alias fo="xdg-open ."
# }}}
# Git {{{
alias gi="git init"
alias subclone="git submodule update --init --recursive"
alias gitdeep="git clone --recursive"
alias gitgraph="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n'' %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all"
alias gitsign="git config commit.gpgsign true"
alias gsi="git submodule update --init"

function ghsclone() {
    if [[ "$1" == "" ]]; then
        echo "Clone what?"
        return -1
    fi;

    git clone "git@github.com:$1"
}

# }}}
# Exposing various binaries {{{
alias themis="~/.vim/plugged/vim-themis/bin/themis"
# }}}
# Hardware {{{
alias noiturbo="echo '1' | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo"
alias iturbo="echo '0' | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo"
alias pulsenodio="pulseaudio -k && sudo alsa force-reload"
# }}}
# Pyenv {{{
alias newpyenv="virtualenv env && source ./env/bin/activate"
# }}}
# Vim {{{
# Hack for gvim: source the pyenv so gvim can access it.
# Workaround in my current dotfiles: :SetVEnv in gvim
# All output is then piped into good 'ol /dev/null because it
# usually spews out bullshit anyway
alias pygvim="source ./env/bin/activate && gvim . > /dev/null 2>&1"
alias pyenv="source ./env/bin/activate"
# }}}
# System {{{
alias sysupdate="sudo apt update && sudo apt upgrade && flatpak update"

# Updates various packages that aren't managed by apt or flatpak.
# This can include stuff _completely_ excluded from other package managers,
# package managers for different programs, or second-class package managers
# (like pip).
function updatePackages() {
    set -x
    go get -v -u github.com/boyter/scc/
    git -C ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k pull
    # Not quitting afterwards in the event something goes wrong
    gvim +PlugUpdate
    set +x
}
# }}}
# Tmux {{{
# **tmux n**ame
alias tmuxn="tmux new-session -t"
# }}}
# Docker {{{
# Start and stop the service
alias rdocker="sudo systemctl start docker"
alias sdocker="sudo systemctl stop docker"

# Temporary docker container (deletes itself)
alias dockertmp="docker run --rm -ti"

# Permanent, named docker container without disconnect
alias dockern="docker run -di --name"

# Shortcut to interactive session
alias dex="docker exec -ti"
alias dstart="docker start"
alias dstop="docker stop"
alias drm="docker rm"

alias powershelldocker="docker run -ti --rm mcr.microsoft.com/powershell:latest"
# }}}
# ffmpeg {{{
# convert standalone MP3s to spotify-compatible audio levels
alias normalize-all-audio="ffmpeg-normalize *.mp3 -c:a libmp3lame -ext mp3 -b:a 320k -f -t -14"
alias normalize-audio="ffmpeg-normalize -c:a libmp3lame -ext mp3 -b:a 320k -f -t -14"
# }}}
# asciinema extensions {{{

function asciinemaProfile() {
    if [[ -n "$1" ]]; then
        ln -sf $HOME/.config/asciinema/install-id-$1 $HOME/.config/asciinema/install-id
    else
        echo "Specify which profile to use"
    fi
}
# }}}
# fail2ban sshd aliases {{{

if [[ $(command -v fail2ban-client) ]]
then
    alias ban="sudo fail2ban-client set sshd banip"
    alias unban="sudo fail2ban-client unban sshd"

    alias breach-attempts="sudo fail2ban-client status sshd"
    alias sshd-auths="cat /var/log/auth.log | grep sshd"

    # Stats on usernames
    alias sshd-auth-bad="cat /var/log/auth.log | grep sshd | grep 'invalid user'"
    alias sshd-auth-pi="cat /var/log/auth.log | grep sshd | grep 'authenticating user pi'"
    # No need to check root, the config has it as an invalid user
fi

# }}}
# ssh {{{
alias sshd-restart="sudo systemctl restart ssh"
# }}}
# You're not funny, Olivia {{{
alias hiya="This isn't the input prompt you're looking for."
alias fuck="echo That piece of shit!"
# }}}
# Command shortening {{{
function mkcd() {
    if [[ "$1" != "" ]]; then
        mkdir $1 && cd $1
    else
        echo "Create what?"
    fi
}
function cleanmk() {
    if [[ "$1" != "" && "$1" != "/" ]]; then
        rm -rf $1 && mkdir $1 && cd $1
    else
        echo "Invalid path, or path was root (rm-ing root is bad!)"
    fi
}
# }}}
# CMake {{{
alias cmaker="cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=1"
alias cmaked="cmake .. -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=1"
# }}}
# Network fuckery {{{
# Only enabled on pihole-enabled devices or my devices in general, because this is aimed at my home network only,
# and remoting into my home network.
if [[ `( nmcli dev list || nmcli dev show ) 2>/dev/null | grep IP4.DNS | grep 192.168.0.179` != '' ]]; then
    # NAS stuff
    function nasmountn() {
        sshfs olivia@shiro.lan:/media/NAS$1 /media/NAS$1
    }
    alias nasmount1="nasmountn 1"
    alias nasmount2="nasmountn 2"
    function nasmountall() {
        nasmountn 1
        nasmountn 2
    }

    # Devices
    alias sshrpi="ssh olivia@sinon.lan"
    alias sshdell="ssh olivia@shiro.lan"
fi
if [[ $USER == "olivia" ]]; then
    # Equivalent to nasmountall, but takes a single IP as input
    # The IP has to be manually configured in ~/.ssh/config first.
    function nasmountremote() {
        if [[ "$1" != "" ]]; then
            sshfs olivia@$1:/media/NAS1 /media/NAS1
            sshfs olivia@$1:/media/NAS2 /media/NAS2
        else
            echo "Invalid IP."
        fi
    }

    function nasumount() {
        umount /media/NAS1
        umount /media/NAS2
    }
fi
# }}}
# Anki {{{
alias ankiinit-flatpak="ANKISYNC_USE_FLATPAK=69 python3 $DOTFILES_HOME/scripts/anki-sync.py pull"
alias ankiinit-normal="ANKISYNC_USE_NORMAL=69 python3 $DOTFILES_HOME/scripts/anki-sync.py pull"

alias ankipull="python3 $DOTFILES_HOME/scripts/anki-sync.py pull"
alias ankipush="python3 $DOTFILES_HOME/scripts/anki-sync.py push"
# }}}
# vim:ft=zsh
